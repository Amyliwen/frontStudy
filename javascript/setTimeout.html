<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>setTimeout</title>
    <script>
        // // function print(){
        //     for (var i = 0; i <= 5; i++){
        //         setTimeout(function () {
        //             console.log(i);
        //         },1000)
        //     }
        // // （1）使用IIFE（立即执行的匿名函数）
        // //间隔1秒依次输出1，2，3，4, 5
        //     for(var i = 1; i <= 5; i++) {
        //         (function(i){
        //             setTimeout(function() {
        //                 console.log(i);
        //             }, i*1000)
        //         })(i);
        //     }
        // //    （2）使用ES6语法中的let来声明变量i
        // //  （3）使用bind方法
        // //bind()方法主要就是将函数绑定到某个对象，bind()会创建一个函数，函数体内的this对象的值会被绑定到传入bind()中的第一个参数的值，例如：f.bind(obj)，实际上可以理解为obj.f()，这时f函数体内的this自然指向的是obj；
        // for (var i = 1; i <= 5; i++){
        //     setTimeout(function (i) {
        //         console.log(i);
        //     }.bind(null, i),i*1000)
        // }
        // var a=1; //声明了一个全局变量
        // function func(){
        //     console.log(a); //输出：undefined。打印a，而在func这个作用域中已经声明了a变量，按照js的执行顺序，此时的a并未被赋值。
        //     var a=1;
        //     console.log(a); //输出：1。
        // }
        // func();

/*        setTimeout(function() {
            console.log(1);
        }, 100)

        setTimeout(function () {
            console.log(2);
        }, 0)

        console.log(3);*/

        console.log('1');

        setTimeout(function() {
            console.log('2');
            // process.nextTick(function() {
            //     console.log('3');
            // })
            new Promise(function(resolve) {
                console.log('4');
                resolve();
            }).then(function() {
                console.log('5')
            })
        })
        // process.nextTick(function() {
        //     console.log('6');
        // })
        new Promise(function(resolve) {
            console.log('7');
            resolve();
        }).then(function() {
            console.log('8')
        })

        setTimeout(function() {
            console.log('9');
            // process.nextTick(function() {
            //     console.log('10');
            // })
            new Promise(function(resolve) {
                console.log('11');
                resolve();
            }).then(function() {
                console.log('12');
            })
        })
        // }
    </script>
</head>
<body>
<!--
知识点：
作用域：把作用域想象成一栋楼，当前执行作用域是一楼，我们在查找变量时，会先在当前执行作用域查找，如果查找不到就坐电梯上上一层查找，顶楼如同全局作用域。
闭包
1、什么是闭包？因为作用域的限制，无法访问其他函数作用域中的变量，闭包是有权访问另一个函数作用域中的变量的函数

setTimeout不是立即执行的，他们的回调会被push到宏任务队列中，再回头执行任务队列中的回调函数时，变量i早就变成了6
1秒后，setTimeout里的函数被推入event queue,而event queue里的任务，只有在主线程空闲下来之后才会去执行。
如果主线程上有很多任务执行，超过1秒，比如执行了10秒，那么这个函数只能在10秒之后才能执行

js代码执行顺序
1、代码的检查装载阶段（预编译阶段），此阶段进行变量和函数的声明，但是不对变量进行赋值，变量的默认值为undefined。
2、代码的执行阶段，此阶段对变量进行赋值和函数的声明。
-->
</body>
</html>
